{
  "top-4": {
    "raw": "# UI 自动化 MVP\n可视化录制 + 后台执行的 UI 自动化平台 MVP（Nuxt 4 / Playwright / Node.js / Docker）。\n\n\n## 可行性判断（结论）\n\n- 本方案可行，但只能定位为“半自动化助手”，不能完全依赖 codegen\n- 录制适合快速成型与覆盖 happy path，长期稳定性依赖标注规范与脚本治理\n- 维护成本主要来自选择器波动与 UI 变更频繁，需制度化约束\n\n维护理念：codegen 仅用于快速生成草稿脚本，稳定回归需要“UI 标注规范 + 脚本治理流程”配合落地。\n详见：[UI 自动化规范与流程](docs/ui-test-standards.md)\n\n\n## 项目概览\n\n演示视频：\n\nhttps://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/Kapture%202025-12-31%20at%2013.56.30.mp4\n\nMonorepo 结构：\n\n```\napps/\n  web/        Nuxt 4 前端\n  recorder/   Playwright codegen 录制服务（headed）\n  executor/   Playwright 执行服务（headless/可视化）\n  shared/     Codegen 类型与脚本生成器/脚本解析\n```\n\n## 开发环境\n\n### 环境要求\n\n- Node.js >= 20\n- pnpm\n\n### 安装\n\n```bash\npnpm install\n```\n\n### 本地开发运行\n\n```bash\npnpm -C apps/recorder start\npnpm -C apps/executor dev\npnpm -C apps/web dev\n```\n\n说明：\n- recorder 使用 `start` 走编译产物（会自动 build）。\n- 如需热更新调试，可使用 `pnpm -C apps/recorder dev`。\n\n打开 `http://localhost:3000/record` 开始录制。\n录制使用 Playwright 官方 `codegen`，会弹出 Inspector 窗口。\n停止录制后，前端会把生成的 Playwright Test 脚本文本 POST 给 executor 并在页面内展示结果。\n也可以在页面点击「手动执行」重新触发执行。\n如需本地可视化执行，可勾选页面内「可视化执行（本地调试）」。\n录制结束会附带 storageState，用于保持 cookie/localStorage 一致。\n\n### 服务地址配置\n\n可通过环境变量覆盖服务地址：\n\n```bash\nexport NUXT_PUBLIC_RECORDER_WS=\"ws://localhost:3001\"\nexport NUXT_PUBLIC_EXECUTOR_HTTP=\"http://localhost:4001\"\nexport NUXT_PUBLIC_EXECUTOR_HTTP_LOCAL=\"http://localhost:4001\"\nexport NUXT_PUBLIC_EXECUTOR_DEBUG_CMD='ssh user@host \"docker compose -f /path/docker-compose.prod.yml exec executor /app/node_modules/.bin/playwright test /app/runs/{runId}/script.spec.mjs --headed --trace on\"'\n```\n\n说明：`NUXT_PUBLIC_EXECUTOR_DEBUG_CMD` 用于自定义“复制调试命令”，可在远程 executor 上执行，并用 `{runId}` 占位。\n\n### 可视化执行与本地 executor\n\n录制页支持“执行目标”切换：\n- 远程（服务器）：使用 `NUXT_PUBLIC_EXECUTOR_HTTP`\n- 本地（可视化）：使用 `NUXT_PUBLIC_EXECUTOR_HTTP_LOCAL`（默认 `http://localhost:4001`）\n\n勾选“可视化执行”会自动切换为本地执行。\n\n### 本地运行打包产物（web + executor）\n\n先构建：\n\n```bash\npnpm -C apps/executor build\npnpm -C apps/web build\n```\n\n分别启动（两个终端）：\n\n```bash\nPORT=4001 node apps/executor/dist/index.js\n```\n\n```bash\nNITRO_PORT=3000 \\\nNUXT_PUBLIC_EXECUTOR_HTTP=http://localhost:4001 \\\nNUXT_PUBLIC_EXECUTOR_HTTP_LOCAL=http://localhost:4001 \\\nNUXT_PUBLIC_RECORDER_WS=ws://localhost:3001 \\\nnode apps/web/.output/server/index.mjs\n```\n\n### 本地 Agent 模式（录制）\n\n适用于服务器无 GUI 的情况：录制在用户本机进行，执行仍在服务器端。\n\n1. 在用户本机启动 Recorder（推荐使用 PM2 守护）\n\n```bash\npm2 start scripts/pm2-recorder.json\npm2 save\n```\n\n2. 在 Web 平台设置本地 Recorder WS 地址\n\n```bash\nexport NUXT_PUBLIC_RECORDER_WS=\"ws://localhost:3001\"\n```\n\n3. 打开 `http://localhost:3000/record` 开始录制\n\n说明：\n- Recorder Agent 仅负责 codegen 录制与脚本推送，不承担执行。\n- 服务器只需要部署 executor（headless）与 web。\n\n### 录制产物（Recorder）\n\n录制过程中 codegen 会写入：\n\n```text\nruns/<id>/script.spec.ts\nruns/<id>/storage-state.json\n```\n\n说明：\n- 默认目录是当前工作目录下的 `runs/`。\n- 可通过 `RECORDER_RUNS_DIR` 指定输出目录（支持绝对路径或相对路径）。\n\n### 使用登录态（load-storage）\n\n录制页提供“使用登录态”下拉，只能选择 Recorder 的 `runs` 目录内已有的 `storage-state.json`。\n\n流程：\n1. 先录制一次生成 `storage-state.json`\n2. 刷新列表，选择对应 runId\n3. 开始录制，会自动使用 `--load-storage`\n\n也可通过环境变量指定默认加载的文件（如果前端未选择）：\n\n```bash\nexport CODEGEN_LOAD_STORAGE_PATH=\"runs/<id>/storage-state.json\"\n```\n\n### Playwright 浏览器\n\n如果缺少 Chromium，请在对应服务目录安装：\n\n```bash\npnpm -C apps/recorder exec playwright install chromium\npnpm -C apps/executor exec playwright install chromium\n```\n\n如果 headless shell 下载受限，可让 executor 指向已有的 Chromium：\n\n```bash\nexport PLAYWRIGHT_CHROMIUM_PATH=\"/absolute/path/to/chromium\"\n```\n\n### 执行接口（Executor API）\n\n```bash\ncurl -X POST http://localhost:4001/execute \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"script\": \"import { test, expect } from \\\"@playwright/test\\\";\\\\nconst params = JSON.parse(process.env.TEST_PARAMS || \\\"{}\\\");\\\\n\\\\ntest(\\\"recorded flow\\\", async ({ page }) => {\\\\n  await page.goto(\\\"https://example.com\\\");\\\\n  await expect(page.getByRole(\\\"heading\\\", { name: \\\"Example Domain\\\" })).toBeVisible();\\\\n});\",\n    \"steps\": [\n      {\n        \"title\": \"打开示例网站\",\n        \"code\": \"await page.goto(\\\"https://example.com\\\");\",\n        \"action\": \"goto\"\n      }\n    ],\n    \"params\": {},\n    \"headless\": true,\n    \"storageState\": {}\n  }'\n```\n\n将 `headless` 设为 `false` 可在本地弹出浏览器（仅本地调试）。\n需确保 executor 运行在有 GUI 的机器上。\n\n产物会写入 `apps/executor/runs/<id>/`。\nexecutor 使用 `playwright test` 执行脚本，并输出 JSON 报告与 Trace。\n执行时会自动注入 `storageState` 并在关键操作后增加基础 `waitForLoadState`。\n\n### 产物下载（HTTP）\n\n```text\nGET /runs/<id>/trace.zip\nGET /runs/<id>/logs.txt\nGET /runs/<id>/result.json\nGET /runs/<id>/report.json\nGET /runs/<id>/steps.json\nGET /runs/<id>/script.mjs\n```\n\n### 本地执行记录\n\n```text\nGET /runs\nDELETE /runs/<id>\n```\n\n### Trace Viewer 回放\n\n```text\nPOST /trace-viewer/start   { \"runId\": \"<id>\" }\nPOST /trace-viewer/stop    { \"runId\": \"<id>\" }\nGET  /trace-viewer/status?runId=<id>\n```\n\n前端会跳转到 `/trace/<id>` 页面，使用 iframe 加载 Trace Viewer。\n调试按钮会在新窗口打开 `/trace/<id>`。\n\n## 生产环境\n\n推荐服务端仅部署 `web` 与 `executor`，录制在用户本机进行。\n生产环境只推荐使用 PM2 守护 recorder。\n\n### Docker Compose（web + executor）\n\n1. 修改 `docker-compose.prod.yml` 中的域名/地址：\n   - `TRACE_VIEWER_HOST`：服务端可访问域名或 IP\n   - `NUXT_PUBLIC_EXECUTOR_HTTP`：executor 对外地址\n   - `NUXT_PUBLIC_RECORDER_WS`：用户本机 recorder 的 WS 地址\n   - 作用：确保 web 能访问 executor/recorder，Trace Viewer 能被外网打开\n\n2. 启动服务：\n\n```bash\ndocker compose -f docker-compose.prod.yml up -d --build\n```\n\n说明：\n- `--build`：基于最新 Dockerfile 构建镜像\n- `-d`：后台运行服务\n\n服务端口：\n- Web: `3000`\n- Executor: `4001`\n- Trace Viewer: `5500-5550`\n\n说明：\nExecutor 映射 `5500-5550` 端口范围是为了支持 Playwright Trace Viewer 的动态启动。\n当用户点击“查看 Trace”时，Executor 会在容器内启动一个新的 Trace Viewer 进程并绑定到该范围内的空闲端口，从而允许同时在浏览器中查看多个不同的测试报告。\n\n### 离线分发镜像\n\n导出（在已构建镜像的机器上）：\n\n```bash\ndocker save -o ui-test-demo-images.tar ui-test-demo-web:latest ui-test-demo-executor:latest\n```\n\n已打包镜像（夸克网盘下载）：\n\n[ui-test-demo-images.tar](https://pan.quark.cn/s/ace1a94f3480)\n\n作用：提供已构建好的 `web` + `executor` 镜像包，离线机器可直接 `docker load` 后启动。\n\n导入与启动（在离线机器上）：\n\n```bash\ndocker load -i ui-test-demo-images.tar\ndocker compose -f docker-compose.prod.yml up -d\n```\n\n说明：\n- 请同时分发 `docker-compose.prod.yml` 及环境变量文件（如有）。\n- 离线机器需与构建机 CPU/系统架构一致（如 arm64/amd64）。\n\n### 使用 PM2 守护 recorder（生产环境推荐）\n\n安装 PM2：\n\n```bash\nnpm install -g pm2\n```\n\n启动 recorder（仓库方式）：\n\n```bash\npm2 start scripts/pm2-recorder.json\npm2 save\n```\n\n启动 recorder（全局包方式）：\n\n```bash\nnpm install -g @fly/recorder\nPORT=3001 pm2 start ui-recorder --name ui-recorder\npm2 save\n```\n\n查看状态与日志：\n\n```bash\npm2 list\npm2 logs ui-recorder\n```\n\n停止/删除：\n\n```bash\npm2 stop ui-recorder\npm2 delete ui-recorder\n```\n\n可用环境变量：\n- `PORT`：recorder 端口，默认 `3001`\n- `RECORDER_RUNS_DIR`：录制产物目录，默认 `runs`（相对当前工作目录）\n- `CODEGEN_LOAD_STORAGE_PATH`：默认加载的 storageState 文件\n\n### Dockerfile 说明（执行端与前端）\n\n`Dockerfile.executor`（Executor）：\n- 基础镜像：`mcr.microsoft.com/playwright`，内置 Playwright 运行环境\n- Builder 阶段：安装依赖并编译 `apps/executor`，产出 `dist`\n- Runtime 阶段：仅复制 `dist` + `node_modules`，减少镜像体积\n\n`Dockerfile.web`（Web）：\n- Builder 阶段：安装依赖并 `nuxt build`，产出 `.output`\n- Runtime 阶段：仅复制 `.output` 并用 `node` 启动服务\n\n### 发布成 npm 包（recorder + shared）\n\n说明：\n- `recorder` 依赖 `shared`，需先发布 `@fly/shared`。\n- 如需使用其他 scope，可替换 `@fly`。\n\n构建：\n\n```bash\npnpm -C apps/shared build\npnpm -C apps/recorder build\n```\n\n发布（示例使用 npmjs；私有仓库请改 registry 与 access 参数）：\n\n```bash\npnpm -C apps/shared publish --access public\npnpm -C apps/recorder publish --access public\n```\n\n安装与运行：\n\n内网需配置 .npmrc\n\n```bash\nregistry=https://registry.npmjs.org/\n@fly:registry=http://nexus.hgj.net/repository/npm-internal/\n```\n\n```bash\nnpm install -g @fly/recorder\nPORT=3001 ui-recorder\n```\n\n说明：全局包启动不依赖当前目录，可在任意路径执行上述命令。\n",
    "source": "http://git.hgj.net/taoxiang.tao/ui-test-demo/raw/master/README.md"
  },
  "top-3": {
    "raw": "# MCP Use × DeepSeek Demo\n\nMCP Use + DeepSeek 的完整链路 Demo，包含 MCP Server/UI resources、MCP Client/Agent、API 层与 Nuxt Web 前端。\n\n![preview](demo.gif)\n\n## 目录\n- `mcp-server/`：订单 Mock 数据与 MCP 工具（get_orders / get_order_detail）。\n- `agent/`：使用 mcp-use + DeepSeek 的 Agent，自动调用 MCP 工具并返回结构化UI Resource / UI Blocks。\n- `web/`：Nuxt 4 + Nuxt UI 的 Chat UI，负责渲染 UI Resource / UI Block。\n- `web/server/`：API 层，负责处理 MCP Client/Agent 的请求。\n- `shared/`：共享类型定义。\n\n## 环境\n- Node.js ≥ 18\n- 包管理：pnpm\n- DeepSeek Key：`DEEPSEEK_API_KEY`（Agent 运行必需）\n\n## 快速开始\n```bash\npnpm install\n\n# 测试 MCP Client 调用\npnpm --filter @demo/agent test:client\n\n# 启动前端（另开终端）\npnpm --filter @demo/web dev\n```\n\n## 渲染逻辑\n- **Agent 输出**：系统提示强制 text / text_delta 以 Markdown 表达，禁止 HTML；UI Resource 仍通过结构化 `ui_resource` block 返回。\n- **Markdown 渲染**：前端采用 [markstream-vue](https://github.com/Simon-He95/markstream-vue)，在 `MessageRenderer` 中对 streaming 文本块做增量渲染，确保打字体验丝滑。\n- **UI Resource 渲染**：`UiResourceRenderer` 仍然按 `resourceId` 拉取 JSON Schema → Vue 组件映射，仅负责渲染（不推理业务），与 Markdown 互不影响。\n\n",
    "source": "https://raw.githubusercontent.com/wingsheep/mcp-use-demo/HEAD/README.md"
  },
  "top-1": {
    "raw": "# hgj/fuxi-mcp\n\n最小化 MCP 服务端，封装 [海管家/伏羲平台](http://next-manage.hgj.net/hgj-ops-admin/home) 的登录、项目查询、发布、消息通知及常用运维接口（服务列表/订阅/分支/构建发布查询等）。\n\n\n## 安装与使用（普通用户）\n- 包位置：`http://nexus.hgj.net/#browse/browse:npm-internal:%40hgj%2Ffuxi-mcp`，包名 `@hgj/fuxi-mcp`。\n- 全局 `.npmrc` 已配私服时：`npm i -g @hgj/fuxi-mcp` 或 `pnpm add -g @hgj/fuxi-mcp`。\n- 未配置私服时显式指定 registry：`npm i -g @hgj/fuxi-mcp --registry=http://nexus.hgj.net/repository/npm-internal/`。\n- 直接运行：`hgj-fuxi-mcp` 或 `npx @hgj/fuxi-mcp`（未配私服时加 `--registry=...`）。\n- 可选环境变量：\n  - 登录免输：`HGJ_FUXI_USERNAME`，`HGJ_FUXI_PASSWORD`，可选 `HGJ_FUXI_ENV=dev|beta|prod`，`HGJ_FUXI_IS_GLOBAL=true|false`。首次登录也可通过命令交互完成，凭据会缓存到 `~/.hgj-fuxi-mcp/auth.json`。\n  - 企业微信群机器人：`HGJ_FUXI_WECOM_GROUPS`（JSON，形如 `[{\"name\":\"测试群\",\"url\":\"...webhook...\"}]`），`HGJ_FUXI_WECOM_MENTIONS`（JSON 数组，支持字符串或对象，例如 `[\"小李\",\"@all\", {\"name\":\"小李\",\"mobile\":\"13800000000\"}]`）。传入对象时会用 `mobile` 填充 `mentioned_mobile_list`，便于仅知道手机号时 @ 指定人。\n\n### 客户端配置（普通用户，全局命令）\n在各客户端将 `command` 设为 `hgj-fuxi-mcp`，无需 `cwd`。\n\n- Codex `config.toml`:\n```toml\n[mcp_servers.hgj-fuxi]\ncommand = \"hgj-fuxi-mcp\"\nenv = { HGJ_FUXI_USERNAME = \"\", HGJ_FUXI_PASSWORD = \"\", HGJ_FUXI_ENV = \"dev\", HGJ_FUXI_IS_GLOBAL = \"false\", HGJ_FUXI_WECOM_GROUPS = \"[{\\\"name\\\":\\\"测试群\\\",\\\"url\\\":\\\"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx\\\"}]\", HGJ_FUXI_WECOM_MENTIONS = \"[\\\"@all\\\",{\\\"name\\\":\\\"小李\\\",\\\"mobile\\\":\\\"13800000000\\\"}]\" }\n```\n\n- Cursor `settings.json`:\n```json\n{\n  \"mcpServers\": {\n    \"hgj-fuxi\": {\n      \"command\": \"hgj-fuxi-mcp\",\n      \"env\": {\n        \"HGJ_FUXI_USERNAME\": \"\",\n        \"HGJ_FUXI_PASSWORD\": \"\",\n        \"HGJ_FUXI_ENV\": \"dev\",\n        \"HGJ_FUXI_IS_GLOBAL\": \"false\",\n        \"HGJ_FUXI_WECOM_GROUPS\": \"[{\\\"name\\\":\\\"测试群\\\",\\\"url\\\":\\\"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx\\\"}]\",\n        \"HGJ_FUXI_WECOM_MENTIONS\": \"[\\\"@all\\\",{\\\"name\\\":\\\"小李\\\",\\\"mobile\\\":\\\"13800000000\\\"}]\"\n      }\n    }\n  }\n}\n```\n\n- Claude 桌面版 `claude_desktop_config.json`:\n```json\n{\n  \"mcpServers\": {\n    \"hgj-fuxi\": {\n      \"command\": \"hgj-fuxi-mcp\",\n      \"env\": {\n        \"HGJ_FUXI_USERNAME\": \"\",\n        \"HGJ_FUXI_PASSWORD\": \"\",\n        \"HGJ_FUXI_ENV\": \"dev\",\n        \"HGJ_FUXI_IS_GLOBAL\": \"false\",\n        \"HGJ_FUXI_WECOM_GROUPS\": \"[{\\\"name\\\":\\\"测试群\\\",\\\"url\\\":\\\"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx\\\"}]\",\n        \"HGJ_FUXI_WECOM_MENTIONS\": \"[\\\"@all\\\",{\\\"name\\\":\\\"小李\\\",\\\"mobile\\\":\\\"13800000000\\\"}]\"\n      }\n    }\n  }\n}\n```\n\n## 开发者调试\n克隆仓库后，本地构建/调试时使用本地文件作为命令，便于热更新。\n\n```bash\npnpm install\n# 热启动（源码直接跑）：pnpm dev\npnpm build            # 生成 dist/mcp-server.js\npnpm start            # 通过 stdio 启动（使用 dist 构建产物）\n# 也可直接：node dist/mcp-server.js\n```\n\n### 发布与更新日志\n- 语义化版本：`pnpm version patch|minor|major`（会写入版本号并打 tag）。\n- 生成/更新日志：`pnpm changelog`（基于 Conventional Commits 生成 `CHANGELOG.md`，未发布的改动请放在 Unreleased 段并在发版前归档）。\n- 检查后提交并推送：`git add CHANGELOG.md package.json pnpm-lock.yaml && git commit -m \"chore(release): vX.Y.Z\" && git push --follow-tags`。\n\n### 客户端配置（开发者，本地路径）\n将 `command` 设为 `node`，`args` 指向本地 `dist/mcp-server.js`（或开发时改为 `tsx src/mcp-server.ts`），`cwd` 填仓库路径。\n\n```toml\n[mcp_servers.hgj-fuxi]\ncommand = \"node\"\nargs = [\"dist/mcp-server.js\"]\ncwd = \"/path/to/hgj-fuxi-mcp\"\nenv = { HGJ_FUXI_USERNAME = \"\", HGJ_FUXI_PASSWORD = \"\", HGJ_FUXI_ENV = \"dev\", HGJ_FUXI_IS_GLOBAL = \"false\", HGJ_FUXI_WECOM_GROUPS = \"[{\\\"name\\\":\\\"测试群\\\",\\\"url\\\":\\\"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx\\\"}]\", HGJ_FUXI_WECOM_MENTIONS = \"[\\\"@all\\\",{\\\"name\\\":\\\"小李\\\",\\\"mobile\\\":\\\"13800000000\\\"}]\" }\n```\n\n## 工具一览\n- 认证：`login`，`whoami`\n- 项目/发布：`getProjectId`，`release`（需明确 branch，支持 `waitForResult`/`followLogs`，可选企业微信通知）\n- 服务：`listServices`，`serviceDetail`，`toggleSubscribe`，`listBranches`\n- 构建发布：`buildStats`，`buildInfo`，`publishInfo`，`latestBuild`，`redeploy`，`stopBuild`\n- 通知联调：`notifyWecom`（企业微信群机器人纯文本测试推送）\n\n## 企业微信群机器人通知\n- 配置来源优先级：调用参数 > 环境变量 > 配置文件 `~/.hgj-fuxi-mcp/wecom.json`，字段形如：\n\n```json\n{\n  \"groups\": [{ \"name\": \"测试群\", \"url\": \"https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx\" }],\n  \"mentions\": [\"小李\", \"@all\", { \"name\": \"小李\", \"mobile\": \"13800000000\" }]\n}\n```\n\n- 发布时可选参数：\n  - `notifyOnStart`: 触发后立即推送。\n  - `notifyOnSuccess`: 发布完成后推送（需要 `waitForResult=true`）。若未等待，会降级发送“已触发但未等结果”的提示。\n  - `notifyGroups`: 群名称列表（未传则使用配置中的全部群）。\n  - `notifyMentions`: 提及人员（未传则使用配置默认值）。\n  - `notifyText`: 自定义前缀文案，例如 `【发布提醒】`。\n  - `notifyConfigFile`: 自定义配置文件路径。\n\n## 认证与缓存\n- 登录信息存储在 `~/.hgj-fuxi-mcp/auth.json`。\n- 若接口返回 401，会自动用缓存凭据重试一次。\n\n## 项目别名\n- 本地文件 `~/.hgj-fuxi-mcp/aliases.json`，格式 `{\"别名\": \"真实项目名\"}`。\n- 设置：提示词“给当前项目设置别名『货车管理后台』”等同调用 `setAlias { \"alias\": \"货车管理后台\" }`，真实项目名默认为当前 git 远端；也可显式传 `projectName`。\n- 使用：发布/查询时传入别名即可（例如提示词“发布货车管理后台”），会优先用别名映射到真实项目名再调用后端。\n\n## 使用方式（在聊天助手内）\n1. 按上文配置好 MCP 服务器并重启助手。\n2. 在对话中直接下达意图，助手会调用相应工具；如果需要特定参数，可以在提示里显式给出。\n3. 服务器会用本地 git 信息回填项目名/分支（当你未提供时），必要时提前在对应仓库目录运行助手。\n\n## 智能提示\n- 在 MCP 配置里通过 env 预置 `HGJ_FUXI_USERNAME` / `HGJ_FUXI_PASSWORD`（可选 `HGJ_FUXI_ENV` / `HGJ_FUXI_IS_GLOBAL`），首次查询/发布会自动登录，无需单独调用 login。\n- 如果没有凭据且直接查询/发布，工具会返回提示，引导补充登录信息。\n\n## 示例提示词\n- 登录：`login { \"username\": \"...\", \"password\": \"...\", \"env\": \"dev\" }`\n- 查询 ID：`getProjectId { \"projectName\": \"demo-app\" }`\n- 发布（需指定分支；可选等待/日志/通知）：`release { \"projectName\": \"demo-app\", \"branch\": \"feature/x\", \"waitForResult\": true, \"followLogs\": true, \"notifyOnStart\": true, \"notifyOnSuccess\": true, \"notifyGroups\": [\"测试群\"], \"notifyMentions\": [\"小李\", \"@all\"], \"notifyText\": \"【发布提醒】\" }`\n- 服务列表：`listServices { \"projectName\": \"pay\", \"includeGlobal\": true }`\n- 服务详情+分支：`serviceDetail { \"id\": \"123\" }`，`listBranches { \"id\": \"123\" }`\n- 构建/发布信息：`buildInfo { \"buildId\": \"456\" }`，`publishInfo { \"buildId\": \"456\" }`\n- 最近构建：`latestBuild { \"serviceId\": \"123\" }`\n- 重新部署/终止：`redeploy { \"buildId\": \"456\" }`，`stopBuild { \"buildId\": \"456\" }`\n- 设置/查看项目别名：`setAlias { \"alias\": \"货车管理后台\", \"projectName\": \"truck-admin\" }`，`listAliases {}`\n\n## 界面示例\n![服务列表与查询](static/demo_query.png)\n![发布与等待](static/demo_deploy.png)\n![日志查看](static/demo_logs.png)\n![项目订阅](static/demo_subscribe.png)\n![国外站查询](static/demo_global.png)\n![企业微信群消息通知](static/demo_notice.png)\n![企业微信群消息通知结果](static/demo_notice_result.png)\n![项目别名](static/demo_alias.png)\n",
    "source": "http://git.hgj.net/taoxiang.tao/hgj-fuxi-mcp/raw/master/README.md"
  },
  "top-2": {
    "raw": "# hgj-cicd\n海管家项目部署脚本导航，按需直达对应说明：\n\n- [`微信小程序`](wechat-mini-program/)\n  - 本地一键打包/上传体验版并推送企业微信群机器人，可通过参数控制环境、备注、跳过构建或通知，含 Raycast 快捷脚本示例。\n\n- [`GitLab 同环境部署通知分支变更`](gitlab/)\n  - 用于在部署完成后，根据流水线中成功的部署 job 识别环境，生成并发送企业微信通知，便于团队及时获知当前环境对应的分支与变更信息。\n\n",
    "source": "http://git.hgj.net/taoxiang.tao/hgj-cicd/raw/master/README.md"
  },
  "vibeCoding-1": {
    "raw": "# 研发委员会 · 制度与项目导航\n\n> 用途说明：帮助有意参与的同事快速了解研发委员会制度与各项开放项目，便于参考与对齐；内容以团队共识为准，欢迎指正完善。\n\n## 一、阅读入口\n\n- 制度总览：\n  - 研发委员会制度说明（职责/机制/激励）：[docs/committee/charter.md](docs/committee/charter.md)\n\n- 项目总览：\n  - 项目一览与执行入口（建议先读）：[docs/projects/README.md](docs/projects/README.md)\n\n- 四个重点项目计划（详细版）：\n  1. 代码规范先行 —— 规范设置与推进（含前端 & Java 扩展）  \n     - 计划文档：[docs/projects/01-code-standards/plan.md](docs/projects/01-code-standards/plan.md)\n  2. AI Coding —— 使用与落地（含通用/前端/后端实践扩展）  \n     - 计划文档：[docs/projects/02-ai-coding/plan.md](docs/projects/02-ai-coding/plan.md)\n  3. UI 自动化 —— 方案与实施（策略与工程双视角）  \n     - 计划文档：[docs/projects/03-ui-automation/plan.md](docs/projects/03-ui-automation/plan.md)\n  4. 前端组件库 —— 方案与长期维护（业务接入 & 维护视角）  \n     - 计划文档：[docs/projects/04-frontend-component-library/plan.md](docs/projects/04-frontend-component-library/plan.md)\n\n## 二、可视化站点（推荐浏览方式）\n\n本仓库配套了一个基于 Vue3 + Vite 的静态站点，用于更直观地浏览制度与项目计划（含流程图和多 Tab 视图）。\n\n- 本地启动：\n  - 安装依赖：`npm install`\n  - 开发预览：`npm run dev`（默认访问 `http://localhost:5173`）\n  - 生产构建：`npm run build`\n  - 预览构建结果：`npm run preview`\n\n- 部署说明（Netlify 示例）：\n  - 构建命令：`npm run build`\n  - 发布目录：`dist`\n  - 重写规则见：[netlify.toml](netlify.toml)\n\n> 建议：日常以网页版本阅读体验最佳，必要时可在 PR 或评审中直接引用对应 markdown 章节。\n",
    "source": "http://git.hgj.net/taoxiang.tao/codemembers/raw/master/README.md"
  },
  "talks-1": {
    "raw": "# talks\nSlides & code for my talks\n\n- [Vue3 优雅的开发项目](./2022-07-10) - Suzhou HGJ 2022\n- [职级晋升](./2023-11-24) - Suzhou HGJ 2023\n",
    "source": "https://raw.githubusercontent.com/wingsheep/talks/HEAD/README.md"
  },
  "talks-2": {
    "raw": "# talks\nSlides & code for my talks\n\n- [Vue3 优雅的开发项目](./2022-07-10) - Suzhou HGJ 2022\n- [职级晋升](./2023-11-24) - Suzhou HGJ 2023\n",
    "source": "https://raw.githubusercontent.com/wingsheep/talks/master/README.md"
  },
  "tools-1": {
    "raw": "<p align=\"center\">\n  <img src=\"./assets/icon.png\" width=\"128\">\n  <h1 align=\"center\">Cosbrowser</h1>\n</p>\n\nA Raycast extension that manage cosbrowser. Powered by [Tencent cosbrowser nodejs sdk](https://cloud.tencent.com/document/product/436/8629).\n\n\n## Motivation\n\nIn daily work, it is often necessary to compress images, upload them to a CDN, and then copy the paths for code development. To simplify this process, this plugin has been developed.\n\n## Features\n\n- Upload & download files\n- Preview images\n- Copy path & snippets\n- Upload history\n- Compress images\n\n## Installation\n\nCurrently, you need to clone this repo and install it locally in developer mode.\n\nYou will need to have [Node.js](https://nodejs.org) and [pnpm](https://pnpm.io/) installed.\n\n1. Clone this repo `git clone https://github.com/wingsheep/cosbrowser`\n2. Go to the folder `cd cosbrowser`\n3. Install dependencies `pnpm install`\n4. Go to Raycast, run `Import Extension` and select the folder\n\nThere is **no plan** to publish to the bloated [raycast/extensions](https://github.com/raycast/extensions) until they make a decentralized publishing system.\n\n## Setup\n\nSettings your Cosbrowser Secret Id & Secret Key & TinyPng key.\n\n| name            | description | required | default |\n| ----------------- | ----------------- | ----------------- | ----------------- |\n| `Secret Id` | Cosbrowser  Secret Id. | true |\n| `Secret Key` | Cosbrowser  Secret Key. | true |\n| `Bucket` | Cosbrowser Bucket. | true |\n| `Region` | Cosbrowser Region. | true | ap-shanghai\n| `Default Prefix` | Configure the addresses of commonly used folders. | false |\n| `Server Domain` | Configure the domain for generating links. | false | \n| `Custom Snippets` | Configure custom snippets with $url & $fileName. | false | `<img :src=`${filePath}$url` alt='$fileName'>`\n| `API Key` | Configure tinyPng api key for compress images. | true |\n| `Destination Folder Path` | Configure folder path for save compressed images. | true |\n\n\n## Commands\n\n| name              | description                                                                                                                                                   |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `View Cosbrowser` | View cosbrowser and then you can upload or download files, preview images and copy custom snippets.                                                                                                                |\n| `Compress & Upload Image` | Compress selected images with TinyPNG. and then upload images. See [here](https://tinypng.com/developers/reference#resizing-images) for more details about the argument. |\n| `Upload History` |  View upload local history data |\n\n## Screenshot\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/view-cosbrowser.png)\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/cosbrowser_actions.png)\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/compress_panel.png)\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/cosbrowser_upload_history.png)\n",
    "source": "https://raw.githubusercontent.com/wingsheep/cosbrowser/HEAD/README.md"
  },
  "tools-4": {
    "raw": "<br>\n<br>\n<p align=\"center\">\n<img src=\"./assets/command-icon.png\" width=\"100\" height=\"100\" align=\"center\" />\n</p>\n\n<h1 align=\"center\">Raycast HGJ OPS</sup></h1>\n\n<p align=\"center\">\n一个海管家伏羲平台的 Raycast 扩展。\n</p>\n\n<img width=\"862\" src=\"./assets/demo.png\">\n\n### 动机\n海管家伏羲平台分为国内站和海外站点，在两个站点的查询发布流程比较繁琐。这个插件整合了两个站点，便于查询发布\n\n## 安装\n\n目前，您需要克隆此仓库并在开发者模式下本地安装。\n\n您需要安装 [Node.js](https://nodejs.org) 和 [pnpm](https://pnpm.io/)。\n\n1. 克隆此仓库 `git clone https://github.com/wingsheep/hgj-ops-raycast.git`\n2. 进入文件夹 `cd hgj-ops-raycast`\n3. 安装依赖 `pnpm install`\n4. 打开 Raycast，运行 `Import Extension` 并选择文件夹\n\n在 [raycast/extensions](https://github.com/raycast/extensions) 制作去中心化发布系统之前，**没有计划** 发布到 bloated。\n\n### 演示视频\n\nhttps://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/hgj-ops-raycast-demo.mp4\n\n### 常规功能\n- 搜索服务\n- 订阅服务\n- 构建部署\n- 取消构建部署\n\n### 特色功能\n- 整合国内站和海外站搜索\n- 选择项目后可切换环境发布\n- 快速查看当前服务最新发布日志\n\n\n## 命令行工具 \nhttp://git.hgj.net/json.zhou/hgj-ops\n\n配合命令行工具食用更佳\n\n享受使用 RayCast HGJ OPS 吧！\n\n",
    "source": "http://git.hgj.net/taoxiang.tao/hgj-ops-raycast/raw/main/README.md"
  },
  "tools-9": {
    "raw": "# Sync GitLab Locale (Tauri v2)\n\n<p align=\"center\">\n  <img src=\"./public/logo.svg\" alt=\"logo\" width=\"100\">\n</p>\n<h2 align=\"center\">Sync GitLab Locale</h2>\n\n跨平台语言包同步工具，源自 Electron 版本的重构。功能等同于脚本项目 [sync-gitlab-locale](http://git.hgj.net/taoxiang.tao/sync-gitlab-locale)：从指定 GitLab 仓库获取语言文件并同步到对应的 API 端点，支持 dev/beta/prod 环境切换（prod 需加密软件）。\n\n## 前提条件\n- 安装 ioA 加密软件；仅安装且允许后可同步 prod。\n- ioA 使用 “WFP 代理”，否则无法访问 GitLab，需能通过 `curl http://git.hgj.net`。\n- 准备 GitLab Private Token，具备读取仓库分支与文件的权限。\n- 开发环境：Node (推荐 pnpm)、Rust toolchain、`@tauri-apps/cli`。\n\n## 功能\n- GitLab Token 验证。\n- 获取最新 10 条分支（按更新时间倒序）。\n- 拉取仓库文件内容（Base64 解码）。\n- 环境切换并持久化配置（`@tauri-apps/plugin-store`）。\n- 跨平台打包（macOS/Windows/Linux）。\n\n## 快速开始（开发）\n```bash\ncorepack enable pnpm   # 如未启用\npnpm install\npnpm run tauri:dev     # 启动 Vite + Tauri，端口占用时会自动切到 5174 等\n```\n仅前端调试可用 `pnpm run dev`。\n\n## 打包\n```bash\npnpm run tauri:build\n```\n产物位于 `src-tauri/target/release/bundle/`，包含 `.app/.dmg`（macOS）或 `.exe/.msi`（Windows）等。\n\n## 下载\n- macOS (Apple Silicon)：[Sync GitLab Locale_0.0.1_aarch64.dmg](./release/Sync%20GitLab%20Locale_0.0.1_aarch64.dmg)\n- windows ：[Sync GitLab Locale_0.0.1_x64-setup.exe](./release/Sync GitLab Locale_0.0.1_x64-setup.exe)\n\n## 其他平台打包\n- Windows：在 Windows 环境安装 Rust + VS Build Tools（含 Windows SDK）、Node/pnpm，运行 `pnpm install && pnpm run tauri:build`，产物在 `src-tauri/target/release/bundle/windows/`。\n- Linux：确保安装系统依赖（如 gtk/ayatana-appindicator 等），同样运行 `pnpm install && pnpm run tauri:build`，产物在 `src-tauri/target/release/bundle/linux/`。\n\n## 配置要点\n- GitLab Host 定义在 `src-tauri/src/lib.rs` 的 `GITLAB_HOST` 常量，如有变化请修改并重新构建。\n- 本地配置存储：`settings.json`（插件自动创建，路径由 Tauri 插件决定）。\n- Dev Server 默认 `http://localhost:5173`，端口占用会自动换号；构建产物目录 `dist`。\n\n## 目录速览\n- `src/`：前端 Vue 代码（Naive UI）。\n- `src/libs/tauri.ts`：封装 Rust 命令调用。\n- `src/libs/store.ts`：配置存取封装（插件 store）。\n- `src-tauri/src/lib.rs`：Tauri 后端逻辑（GitLab API 调用等）。\n- `src-tauri/tauri.conf.json`：Tauri 配置。\n- `src-tauri/icons/icon.png`：应用图标（PNG RGBA）。\n\n## 示例\n![home demo](./public/home-demo.png)\n\n![config demo](./public/config-demo.png)\n",
    "source": "http://git.hgj.net/taoxiang.tao/sync-locale-app_by_tauri-v2/raw/master/README.md"
  },
  "tools-6": {
    "raw": "<p style=\"text-align: center\">\r\n  <img style=\"width: 100px\" src=\"./public/logo.svg\">\r\n</p>\r\n<h2 style=\"text-align: center\">Sync GitLab Locale</h2>\r\n\r\n## 海外舱单语言包同步 跨平台app\r\n\r\n### 动机\r\n该 app 旨在在本地和远程 GitLab 仓库之间同步语言包，适用于国内和海外环境。 此项目功能与[sync-gitlab-locale](http://git.hgj.net/taoxiang.tao/sync-gitlab-locale)脚本实现一致，都是从指定的 GitLab 仓库获取语言文件，并将其更新到相应的 API 端点。但是由于ipa加密软件的限制，脚本只适用于开发 dev beta 环境，测试发布prod需本地部署脚本使用比较麻烦。因此开发了此跨平台可视化 app 适用于不用环境，应用中切换同步环境自动检测是否可以同步，安装了加密软件的平台才可同步 prod。\r\n\r\n### 前提条件\r\n- 需安装ioA 加密软件，否则无法访问同步到[ prod 后台管理系统](http://manage.hgj.net/unified-web/sign-in)\r\n- ioA 需使用“WFP代理”，否则终端无法访问Gitlab，测试 `curl http://git.hgj.net`\r\n\r\n### 下载\r\n- macos\r\n[Sync GitLab Locale-Mac-0.0.1-Installer.dmg](./release/0.0.1/Sync%20GitLab%20Locale-Mac-0.0.1-Installer.dmg)\r\n\r\n- windows\r\n[Sync GitLab Locale-Windows-0.0.1-Setup.exe](./release/0.0.1/Sync%20GitLab%20Locale-Windows-0.0.1-Setup.exe)\r\n\r\n### 示例\r\n![home demo](./public/home-demo.png)\r\n\r\n![config demo](./public/config-demo.png)\r\n\r\n",
    "source": "http://git.hgj.net/taoxiang.tao/sync-locale-app/raw/master/README.md"
  },
  "tools-5": {
    "raw": "<h1>\n  CodeVar\n  <img src=\"./assets/command-icon.png\" width=\"90px\" align=\"right\" />\n</h1>\n\nCodeVar is a variable naming tool for [Raycast](https://www.raycast.com/) extensions powered by YouDao translate api.\n\nBased on the git repository changes at [https://github.com/ifyour/code-var](https://github.com/ifyour/code-var)\n\n### Usage\n\nTo use CodeVar, follow these steps:\n\n```bash\n# Clone the repository by running the following command in your terminal:\ngit clone https://github.com/wingsheep/code-var.git\n\n# Navigate to the cloned repository by running the following command:\ncd code-var\n\n# Start the development server by running the following command:\nnpm i && npm run dev\n```\n\n### Screenshot\n\nCall up Raycast and search for CodeVar. Input the variable you want to translate, and press `Enter` to copy it to the clipboard. Alternatively, you can press `Cmd` + `Enter` to copy and paste it.\n\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/codevar.png)\n\nIn addition, you can carry a parameter that can be used to query multiple results in a specified format\n\n```ts\n/** The type of query alias */\nexport enum CASES_ALIAS  {\n  \"xt\" = \"camelCase\",\n  \"dt\" = \"pascalCase\",\n  \"cl\" = \"constantCase\",\n  \"xh\" = \"snakeCase\",\n}\n```\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/xt.png)\n\n![](https://cdn.jsdelivr.net/gh/wingsheep/FigureBed@master/img/xt2.png)\n\n\n Enjoy using CodeVar!\n\n### License\n\nCodeVar is licensed under the MIT License.\n",
    "source": "http://git.hgj.net/taoxiang.tao/code-var/raw/main/README.md"
  },
  "tools-2": {
    "raw": "# 油猴脚本\n工作中难免会遇到的一些重复的步骤导致心情很不美丽，使用脚本解决省心省力\n\n\n- [粘贴文本快速创建tapd拆分任务, 支持根据数学表达式计算工时](./tapd_quick_text_add_task/README.md)\n\n\n- [微信小程序审核状态推送至企业微信群机器人](./wechat_mini_publish_state_push/README.md)\n\n\n- [伏羲平台（内部）工作负载支持query参数打开指定job&env](./fuxi_url_query/README.md)\n\n- [拦截接口快捷搜索支持拼音](./quick-search-by-interpected-api//README.md)\n\n- [Tapd计算当前页面预估总工时](./tapd_calc_total_estimated_working_hours/README.md)\n\n- [Codesign 支持生成 UnoCss 类名和复制功能](./codesign_add_copy_unocss/README.md)\n\n",
    "source": "https://raw.githubusercontent.com/wingsheep/tampermonkey-script/HEAD/README.md"
  },
  "experiments-1": {
    "raw": "# ehr-app\n\nAn Electron application based on EHR data displaying daily working hours.\n\n## Feature\n\n-  The app calculates the end time of a workday based on the start time and displays a countdown in the system tray.\n- The app automatically logs in to a system or website based on pre-configured settings.\n\n## Recommended IDE Setup\n\n- [VSCode](https://code.visualstudio.com/) + [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) + [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar)\n\n## Project Setup\n\n### Install\n\n```bash\n$ pnpm install\n```\n\n### Development\n\n```bash\n$ pnpm dev\n```\n\n### Build\n\n```bash\n# For windows\n$ pnpm build:win\n\n# For macOS\n$ pnpm build:mac\n\n# For Linux\n$ pnpm build:linux\n```\n\n\n### DEMO\n![](./PixPin_2025-01-21_20-01-52.png)\n",
    "source": "https://raw.githubusercontent.com/wingsheep/ehr-app/HEAD/README.md"
  },
  "experiments-2": {
    "raw": "# Certbot 自动续期 + 七牛云证书上传（整理版）\n\n本项目用于自动续期 Let's Encrypt 证书，并在续期成功后自动把证书上传到七牛云 CDN。已对原有文件进行分层整理：配置文件、七牛脚本、Certbot 脚本与 hooks、说明文档。\n\n## 项目结构\n\n```\n.\n├── requirements.txt                  # Python 依赖\n├── config/                            # 配置示例\n│   ├── qiniu_env.example\n│   └── （已移除阿里云插件示例，改用 Aliyun CLI 手动 DNS 验证）\n├── docs/                              # 说明文档\n│   ├── GETTING_STARTED.md             # 快速开始（替代 OVERVIEW）\n│   ├── USER_GUIDE.md                  # 用户指南与系统说明\n│   ├── CERTBOT_HOOKS.md               # Certbot Hooks 说明\n│   └── DNS_MANUAL_ALIYUN.md           # DNS 手动验证（Aliyun CLI）\n└── scripts/\n    ├── install.sh                     # 一键安装到系统目录\n    ├── certbot/                       # Certbot 相关脚本\n    │   ├── auto_cert_renewal.sh       # HTTP 验证自动续期\n    │   ├── dns_cert_renewal.sh        # DNS 验证获取/续期\n    │   ├── test_all_config.sh         # 配置检查\n    │   └── hooks/\n    │       ├── dns/                   # Certbot 手动 DNS 验证 hooks\n    │       │   ├── dns_auth_hook.sh\n    │       │   └── dns_cleanup_hook.sh\n    │       └── renewal/               # Certbot 标准 renewal hooks（系统安装路径）\n    │           ├── pre/backup-certs.sh\n    │           ├── deploy/upload-to-qiniu.sh\n    │           └── post/reload-nginx.sh\n    └── qiniu/                         # 七牛云相关脚本\n        ├── upload_cert_to_qiniu.py    # 上传证书\n        ├── verify_qiniu_auth.py       # QBox 签名验证\n        └── test_qiniu_api.py          # API 权限自测\n```\n\n安装后运行目录：`/etc/nginx/cert-automation`，Certbot hooks 安装到 `/etc/letsencrypt/renewal-hooks/{pre,deploy,post}`。\n\n## 快速开始\n\n1) 安装（需 root）：\n```bash\nsudo bash scripts/install.sh\n```\n\n2) 配置密钥：\n```bash\ncd /etc/nginx/cert-automation\ncp qiniu_env.example qiniu_env.sh && vim qiniu_env.sh\n# 可选（DNS 自动验证）：\n# DNS 验证改为 Aliyun CLI + 手动 hooks，无需 certbot-dns-aliyun 插件\n```\n\n3) 选择验证方式：\n- 域名直连服务器（HTTP 验证）：`/etc/nginx/cert-automation/auto_cert_renewal.sh`\n- 域名走 CDN（DNS 验证）：`/etc/nginx/cert-automation/dns_cert_renewal.sh`\n\n4) 验证：\n```bash\ncertbot renew --dry-run\n```\n\n## 一键安装 Aliyun CLI（yum/apt）\n\n以下命令用于安装 DNS 手动验证所需的依赖（Aliyun CLI + jq + dig），并配置默认 profile（certbot）。\n\n```bash\n# RHEL/CentOS（yum）\nsudo yum install -y epel-release jq bind-utils && \\\ncurl -sS https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz | tar -xz && \\\nsudo mv aliyun /usr/local/bin/ && aliyun version && \\\nsudo aliyun configure set --profile certbot \\\n  --access-key-id <AK> --access-key-secret <SK> \\\n  --region cn-hangzhou --language zh\n\n# Debian/Ubuntu（apt）\nsudo apt update && sudo apt install -y jq dnsutils && \\\ncurl -sS https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz | tar -xz && \\\nsudo mv aliyun /usr/local/bin/ && aliyun version && \\\nsudo aliyun configure set --profile certbot \\\n  --access-key-id <AK> --access-key-secret <SK> \\\n  --region cn-hangzhou --language zh\n```\n\n注意：请将 `<AK>/<SK>` 替换为具有 AliDNS 解析权限的子账号密钥。\n\n## 日志位置\n- 安装：`/var/log/nginx/install.log`\n- 续期：`/var/log/nginx/cert_renewal.log`\n- DNS 验证：`/var/log/nginx/dns_cert_renewal.log`\n- Hook：\n  - Pre：`/var/log/nginx/certbot_pre.log`\n  - Deploy：`/var/log/nginx/certbot_deploy.log`\n  - Post：`/var/log/nginx/certbot_post.log`\n- 七牛上传：`/etc/nginx/qiniu_cert_upload.log`\n\n## 日常维护常用命令\n\n```bash\n# 查看所有证书\ncertbot certificates\n\n# 预演续期（不改动实际证书）\ncertbot renew --dry-run\n\n# 手动执行 (真替换并上传证书)\ncertbot renew --force-renewal -v\n\n# 检查指定域名证书到期时间\nDOMAIN=file.example.com\nopenssl x509 -in /etc/letsencrypt/live/$DOMAIN/fullchain.pem -noout -dates\n\n# 查看最新日志\ntail -f /var/log/nginx/cert_renewal.log\ntail -f /etc/nginx/qiniu_cert_upload.log\ntail -f /var/log/nginx/certbot_deploy.log\n\n# 手动触发一次七牛证书上传（证书已更新）\ncd /etc/nginx/cert-automation && source qiniu_env.sh && python3 upload_cert_to_qiniu.py\n\n# 校验并重载 nginx 配置\nnginx -t && sudo systemctl reload nginx\n\n# 检查 Aliyun CLI 配置与权限\naliyun configure list\naliyun --profile certbot alidns DescribeDomains --PageSize 1\n\n# 检查 DNS TXT 是否生效\ndig +short TXT _acme-challenge.$DOMAIN\n\n# 查看定时任务\ncrontab -l\n# Certbot DNS验证自动续期 - 每月1号凌晨2点检查\n0 2 1 * * certbot renew --preferred-challenges=dns --quiet\n\n# 备用方案 - 每3个月强制使用DNS验证检查\n0 3 1 */3 * certbot renew --preferred-challenges=dns --force-renewal\n```\n\n## 说明\n- 仅整理仓库目录，运行时路径保持为 `/etc/nginx/cert-automation`，避免影响已部署环境。\n- 修正了 `scripts/certbot/auto_cert_renewal.sh` 中的安装目录变量，默认从 `qiniu_env.sh` 加载密钥。\n- 详细指引见 `docs/`。\n",
    "source": "https://raw.githubusercontent.com/wingsheep/ops/HEAD/README.md"
  }
}
